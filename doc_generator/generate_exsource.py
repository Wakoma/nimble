"""
Orchestration script using exsource
"""

import os
import json
from pathlib import Path
import shutil

from utility.device import Device
from utility.exsource_def_generator import ExsourceDefGenerator
from utility.assembly_def_generator import AssemblyDefGenerator


class OrchestrationRunner:
    """
    Set up everything needed to generate the documentation for a specific configuration.
    This includes:
    Prepare build environment,
    generate exsource definition file,
    generate assembly definition file,
    generate gitbuilding files
    """
    _config: dict
    _config_hash: str
    _force_rebuild: bool
    _module_path: Path
    _build_dir: Path
    _outputdir_gitbuilding: Path
    _outputdir_stl: Path
    _outputdir_svg: Path
    _outputdir_step: Path

    def __init__(self, config, config_hash, force_rebuild=True) -> None:
        """
        Create runner instance.
        """
        self._config = config
        self._config_hash = config_hash
        self._force_rebuild = force_rebuild

    def setup(self):
        """
        Set up build environment.
        """
        # get path of this python file
        self._module_path = Path(__file__).resolve().parent

        self._build_dir = self._module_path / "build" / self._config_hash
        self._build_dir = self._build_dir.resolve()
        build_dir_identification_file = "NIMBLE_BUILD"

        if os.path.exists(self._build_dir):
            if self._force_rebuild:
                # for safety, only delete if build dir is identified as such
                if not os.path.exists(self._build_dir / build_dir_identification_file):
                    print(
                        "build dir exists but is not identified as such, refusing to delete")
                    raise Exception(
                        "build dir exists but is not identified as such, refusing to delete")
                shutil.rmtree(self._build_dir)
            else:
                print("build dir already exists, skipping")
                return

        self._outputdir_gitbuilding = self._build_dir / "gitbuilding"
        self._outputdir_stl = self._outputdir_gitbuilding / "models"
        self._outputdir_svg = self._outputdir_gitbuilding / "svg"
        self._outputdir_step = self._build_dir / "step"

        # set up build env

        try:
            os.mkdir(self._build_dir)
            with open(self._build_dir / build_dir_identification_file, 'w') as f:
                f.write(
                    "The contents of this directory are generated by the NIMBLE build system. Do not edit manually.")
            os.mkdir(self._outputdir_gitbuilding)
            os.mkdir(self._outputdir_stl)
            os.mkdir(self._outputdir_svg)
            os.mkdir(self._outputdir_step)
        except OSError:
            print("failed to create output dir")
            raise

        # copy mechanical folder into build dir
        try:
            shutil.copytree(self._module_path / "mechanical",
                            self._build_dir / "mechanical")
        except OSError:
            print("failed to copy mechanical folder")
            raise



    def generate_exsource_files(self):
        """
        generate documentation for a specific configuration
        """

        # parameters

        # TODO: get from input
        # selected_devices_ids = config.devices
        selected_devices_ids = ['NUC10i5FNH', 'RPi4', 'RPi4']
        json_filename = self._module_path / "devices.json"

        # read json, select entries

        selected_devices = []
        with open(json_filename) as json_file:
            data = json.load(json_file)
            find_device = lambda id: next((x for x in data if x['ID'] == id), None)
            selected_devices = [Device(find_device(x)) for x in selected_devices_ids]

        print([x.id for x in selected_devices])

        # calculate assembly dimensions

        beam_width = 20
        single_width = 155
        tray_width = single_width - 2 * beam_width
        tray_depth = 115
        mounting_hole_spacing = 14
        base_plate_thickness = 3
        top_plate_thickness = 3
        base_clearance = 4


        beam_height = base_clearance
        hole_count = 0
        for device in selected_devices:
            beam_height += device.height_in_units * mounting_hole_spacing
            hole_count += device.height_in_units

        # collect all needed parts and their parameters

        exsource: ExsourceDefGenerator = ExsourceDefGenerator()

        # rack legs (4 identical ones)
        exsource.add_part(
            name="rack_leg",
            description="3D printed rack leg",
            output_files=["./step/beam.step"],
            source_files=["./mechanical/components/cadquery/rack_leg.py"],
            parameters={
                "length": beam_height,
                "hole_spacing": mounting_hole_spacing,
            },
            application="cadquery"
        )

        # base plate
        exsource.add_part(
            name="baseplate",
            description="3D printed base plate",
            output_files=["./step/baseplate.step"],
            source_files=["./mechanical/components/cadquery/base_plate.py"],
            parameters={
                "width": single_width,
                "depth": single_width,
            },
            application="cadquery"
        )

        # top plate
        exsource.add_part(
            name="topplate",
            description="3D printed top plate",
            output_files=["./step/topplate.step"],
            source_files=["./mechanical/components/cadquery/top_plate.py"],
            parameters={
                "width": single_width,
                "depth": single_width,
            },
            application="cadquery"
        )

        # set of needed trays
        trays = set()
        for device in selected_devices:
            tray_id = device.get_tray_id()
            if tray_id in trays:
                continue  # already added
            trays.add(tray_id)
            exsource.add_part(
                name=tray_id,
                description="tray for " + device.name,
                output_files=[f"./step/{tray_id}.step"],
                source_files=["mechanical/components/cadquery/nimble_tray.py"],
                parameters={
                    "height_in_hole_unites": device.height_in_units,
                    "tray_width": tray_width,
                    "tray_depth": tray_depth,
                },
                application="cadquery"
            )

        #######################
        # create assembly

        assembly = AssemblyDefGenerator(exsource)

        # base plate
        assembly.add_part(
            name="baseplate",
            part_name="baseplate",
            position=(0, 0, 0),
            assembly_step="1"
        )

        # 4 rack legs
        hole_pos = (single_width - beam_width) / 2.0
        assembly.add_part(
            name="rack_leg1",
            part_name="rack_leg",
            position=(-hole_pos, -hole_pos, base_plate_thickness),
            assembly_step="2"
        )
        assembly.add_part(
            name="rack_leg2",
            part_name="rack_leg",
            position=(+hole_pos, -hole_pos, base_plate_thickness),
            assembly_step="2"
        )
        assembly.add_part(
            name="rack_leg3",
            part_name="rack_leg",
            position=(+hole_pos, +hole_pos, base_plate_thickness),
            assembly_step="2"
        )
        assembly.add_part(
            name="rack_leg4",
            part_name="rack_leg",
            position=(-hole_pos, +hole_pos, base_plate_thickness),
            assembly_step="2"
        )

        # top plate
        assembly.add_part(
            name="topplate",
            part_name="topplate",
            position=(0, 0, beam_height + base_plate_thickness),
            assembly_step="3"
        )
        # todo roatation
        #    topplate = topplate.rotateAboutCenter((1, 0, 0), 180)
        #    topplate = topplate.rotateAboutCenter((0, 0, 1), 180)

        # all the trays
        zpos = 5
        for (index, device) in enumerate(selected_devices):
            assembly.add_part(
                name=f"tray_{index}",
                part_name=device.get_tray_id(),
                position=(-tray_width / 2.0, -single_width / 2.0 - 4, zpos),
                assembly_step="4"
            )
            zpos += device.height_in_units * mounting_hole_spacing

        # save assembly definition
        assembly.save(self._build_dir / "assembly-def.yaml")

        # add assembly to exsource
        exsource.add_part(
            name="assembly",
            description="assembly",
            output_files=[
                "./step/assembly.stl",
                # "./step/assembly.step",
                "./step/assembly.gltf",
            ],
            source_files=["./mechanical/assembly_renderer.py"],
            parameters={
                "assembly_definition_file": "assembly-def.yaml",
            },
            application="cadquery",
            dependencies=assembly.get_step_files()
        )

        # save exsource definition
        exsource.save(self._build_dir / "exsource-def.yaml")

        # export SVGs

        # export_svg(createAssembly(1), self._outputdir_svg / "baseplate.svg")
        # export_svg(createAssembly(2), self._outputdir_svg / "baseplate_beams.svg")
        # export_svg(createAssembly(3), self._outputdir_svg / "baseplate_beams_topplate.svg")
        # export_svg(createAssembly(4), self._outputdir_svg / "trays.svg")


        print("Finished genrating exsource for config_hash: " + self._config_hash)


# if main script, run generate_docs with test config
if __name__ == "__main__":
    config = {'config': {'server_1': 'Hardware_1', 'router_1': 'Hardware_2',
                         'switch_1': 'Hardware_9', 'charge_controller_1': 'Hardware_4'}}
    runner = OrchestrationRunner(config, "test_config_hash")
    runner.setup()
    runner.generate_exsource_files()
