"""
Orchestration script using exsource
"""

import os
import json
from pathlib import Path
import shutil

from utility.device import Device
from utility.exsource_def_generator import ExsourceDefGenerator
from utility.assembly_def_generator import AssemblyDefGenerator


class OrchestrationRunner:
    """
    Set up everything needed to generate the documentation for a specific configuration.
    This includes:
    Prepare build environment,
    generate exsource definition file,
    generate assembly definition file,
    generate gitbuilding files
    """
    _config: dict
    _config_hash: str
    _force_rebuild: bool
    _module_path: Path
    _build_dir: Path
    _outputdir_gitbuilding: Path
    _outputdir_stl: Path
    _outputdir_svg: Path
    _outputdir_step: Path

    def __init__(self, config, config_hash, force_rebuild=True) -> None:
        """
        Create runner instance.
        """
        self._config = config
        self._config_hash = config_hash
        self._force_rebuild = force_rebuild

    def setup(self):
        """
        Set up build environment.
        """
        # get path of this python file
        self._module_path = Path(__file__).resolve().parent

        self._build_dir = self._module_path / "build" / self._config_hash
        self._build_dir = self._build_dir.resolve()
        build_dir_identification_file = "NIMBLE_BUILD"

        if os.path.exists(self._build_dir):
            if self._force_rebuild:
                # for safety, only delete if build dir is identified as such
                if not os.path.exists(self._build_dir / build_dir_identification_file):
                    print(
                        "build dir exists but is not identified as such, refusing to delete")
                    raise Exception(
                        "build dir exists but is not identified as such, refusing to delete")
                shutil.rmtree(self._build_dir)
            else:
                print("build dir already exists, skipping")
                return

        self._outputdir_gitbuilding = self._build_dir / "gitbuilding"
        self._outputdir_stl = self._outputdir_gitbuilding / "models"
        self._outputdir_svg = self._outputdir_gitbuilding / "svg"
        self._outputdir_step = self._build_dir / "step"

        # set up build env

        try:
            os.mkdir(self._build_dir)
            with open(self._build_dir / build_dir_identification_file, 'w') as f:
                f.write(
                    "The contents of this directory are generated by the NIMBLE build system. Do not edit manually.")
            os.mkdir(self._outputdir_gitbuilding)
            os.mkdir(self._outputdir_stl)
            os.mkdir(self._outputdir_svg)
            os.mkdir(self._outputdir_step)
        except OSError:
            print("failed to create output dir")
            raise

        # copy mechanical folder into build dir
        try:
            shutil.copytree(self._module_path / "mechanical",
                            self._build_dir / "mechanical")
        except OSError:
            print("failed to copy mechanical folder")
            raise



    def generate_docs(self):
        """
        generate documentation for a specific configuration
        """

        # parameters

        # TODO: get from input
        # selected_devices_ids = config.devices
        selected_devices_ids = ['NUC10i5FNH', 'RPi4']
        json_filename = self._module_path / "devices.json"

        # read json, select entries

        selected_devices = []
        with open(json_filename) as json_file:
            data = json.load(json_file)
            selected_devices = [Device(x)
                                for x in data if x['ID'] in selected_devices_ids]

        print([x.id for x in selected_devices])

        # calculate assembly dimensions

        single_width = 155
        beam_height = 4
        for device in selected_devices:
            if device.height_in_units == 2:
                beam_height += 27
            elif device.height_in_units == 3:
                beam_height += 42
            elif device.height_in_units == 4:
                beam_height += 55

        # collect all needed parts and their parameters

        exsource: ExsourceDefGenerator = ExsourceDefGenerator()

        # rack legs (4 identical ones)
        exsource.add_part(
            name="rack_leg",
            description="3D printed rack leg",
            output_files=["./step/beam.step"],
            source_files=["./mechanical/components/cadquery/rack_leg.py"],
            parameters={
                "length": beam_height,
            },
            application="cadquery"
        )

        # base plate
        exsource.add_part(
            name="baseplate",
            description="3D printed base plate",
            output_files=["./step/baseplate.step"],
            source_files=["./mechanical/components/cadquery/nimble_end_plate.py"],
            parameters={
                "width": single_width,
                "height": single_width,
            },
            application="cadquery"
        )

        # top plate
        exsource.add_part(
            name="topplate",
            description="3D printed top plate",
            output_files=["./step/topplate.step"],
            source_files=["./mechanical/components/cadquery/nimble_end_plate.py"],
            parameters={
                "width": single_width,
                "height": single_width,
            },
            application="cadquery"
        )

        # set of needed trays
        trays = set()
        for device in selected_devices:
            tray_id = device.get_tray_id()
            if tray_id in trays:
                continue  # already added
            trays.add(tray_id)
            exsource.add_part(
                name=tray_id,
                description="tray for " + device.name,
                output_files=[f"./step/{tray_id}.step"],
                source_files=["mechanical/components/cadquery/nimble_tray.py"],
                parameters={
                    "height_in_hole_unites": device.height_in_units,
                },
                application="cadquery"
            )

        #######################
        # create assembly

        assembly = AssemblyDefGenerator(exsource)

        # base plate
        assembly.add_part(
            name="baseplate",
            part_name="baseplate",
            position=(0, 0, 0),
            assembly_step="1"
        )

        # 4 rack legs
        assembly.add_part(
            name="rack_leg1",
            part_name="rack_leg",
            position=(-single_width / 2.0 + 10, -single_width / 2.0 + 10, 3),
            assembly_step="2"
        )
        assembly.add_part(
            name="rack_leg2",
            part_name="rack_leg",
            position=(single_width / 2.0 - 10, -single_width / 2.0 + 10, 3),
            assembly_step="2"
        )
        assembly.add_part(
            name="rack_leg3",
            part_name="rack_leg",
            position=(single_width / 2.0 - 10, single_width / 2.0 - 10, 3),
            assembly_step="2"
        )
        assembly.add_part(
            name="rack_leg4",
            part_name="rack_leg",
            position=(-single_width / 2.0 + 10, single_width / 2.0 - 10, 3),
            assembly_step="2"
        )

        # top plate
        assembly.add_part(
            name="topplate",
            part_name="topplate",
            position=(0, 0, beam_height + 3),
            assembly_step="3"
        )
        # todo roatation
        #    topplate = topplate.rotateAboutCenter((1, 0, 0), 180)
        #    topplate = topplate.rotateAboutCenter((0, 0, 1), 180)

        # all the trays
        for (index, device) in enumerate(selected_devices):
            assembly.add_part(
                name=f"tray_{index}",
                part_name=device.get_tray_id(),
                position=(-115 / 2, -155 / 2 - 4, 4 + index *
                          device.height_in_units * 27 / 2),
                assembly_step="4"
            )

        # save assembly definition
        assembly.save(self._build_dir / "assembly-def.yaml")

        # add assembly to exsource
        exsource.add_part(
            name="assembly",
            description="assembly",
            output_files=["./step/assembly.step"],
            source_files=["assembly_renderer.py"],
            parameters={
                "assembly": "assembly-def.yaml",
            },
            application="cadquery",
            dependencies=assembly.get_step_files()
        )

        # save exsource definition
        exsource.save(self._build_dir / "exsource-def.yaml")

        # export SVGs

        # export_svg(createAssembly(1), self._outputdir_svg / "baseplate.svg")
        # export_svg(createAssembly(2), self._outputdir_svg / "baseplate_beams.svg")
        # export_svg(createAssembly(3), self._outputdir_svg / "baseplate_beams_topplate.svg")
        # export_svg(createAssembly(4), self._outputdir_svg / "trays.svg")

        # write gitbuilding files
        # todo

        print("Finished build for config_hash: " + self._config_hash)


# if main script, run generate_docs with test config
if __name__ == "__main__":
    config = {'config': {'server_1': 'Hardware_1', 'router_1': 'Hardware_2',
                         'switch_1': 'Hardware_9', 'charge_controller_1': 'Hardware_4'}}
    runner = OrchestrationRunner(config, "test_config_hash")
    runner.setup()
    runner.generate_docs()
